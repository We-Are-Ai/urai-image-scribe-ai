
// Real image generation with Gemini API

export interface ImageGenerationResponse {
  imageUrl: string;
}

// Demo image URLs as fallback if API calls fail
const demoImageCategories = {
  nature: [
    "https://images.unsplash.com/photo-1579546929518-9e396f3cc809", // Aurora
    "https://images.unsplash.com/photo-1470071459604-3b5ec3a7fe05", // Forest
    "https://images.unsplash.com/photo-1501854140801-50d01698950b"  // Mountains
  ],
  abstract: [
    "https://images.unsplash.com/photo-1516116216624-53e697fedbea", // Abstract light
    "https://images.unsplash.com/photo-1557672172-298e090bd0f1", // Colorful abstract
    "https://images.unsplash.com/photo-1574169208507-84376144848b"  // Abstract art
  ],
  technology: [
    "https://images.unsplash.com/photo-1682686581221-c129e7636df8", // Tech workspace
    "https://images.unsplash.com/photo-1550745165-9bc0b252726f", // VR headset
    "https://images.unsplash.com/photo-1518770660439-4636190af475"  // Tech gadgets
  ]
};

const API_KEY = "AIzaSyCI9781rp3kenGrEGF0K38nWVklNbn9oWo"; // Gemini API key

// Helper function to select a fallback category based on prompt keywords
const selectCategory = (prompt: string): string[] => {
  prompt = prompt.toLowerCase();
  
  if (prompt.includes('nature') || prompt.includes('landscape') || 
      prompt.includes('mountain') || prompt.includes('forest') ||
      prompt.includes('sky') || prompt.includes('water')) {
    return demoImageCategories.nature;
  } else if (prompt.includes('tech') || prompt.includes('computer') || 
             prompt.includes('digital') || prompt.includes('future') ||
             prompt.includes('robot') || prompt.includes('ai')) {
    return demoImageCategories.technology;
  } else {
    return demoImageCategories.abstract;
  }
};

export const generateImageWithGemini = async (prompt: string): Promise<ImageGenerationResponse> => {
  try {
    // Using the Gemini API to generate images
    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${API_KEY}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        contents: [
          {
            parts: [
              { text: `Generate an image based on this prompt: ${prompt}` }
            ]
          }
        ],
        generation_config: {
          temperature: 0.8,
          top_p: 0.95,
          top_k: 40,
          max_output_tokens: 2048,
        },
      }),
    });

    const data = await response.json();
    
    // Check if the response contains image data
    if (data.candidates && data.candidates[0]?.content?.parts) {
      for (const part of data.candidates[0].content.parts) {
        if (part.inline_data && part.inline_data.mime_type.startsWith('image/')) {
          return {
            imageUrl: `data:${part.inline_data.mime_type};base64,${part.inline_data.data}`
          };
        }
      }
    }
    
    // If no image was generated via API, fall back to the demo images
    console.warn("No image generated by API, falling back to demo images");
    const categoryImages = selectCategory(prompt);
    return {
      imageUrl: categoryImages[Math.floor(Math.random() * categoryImages.length)]
    };
  } catch (error) {
    console.error('Error generating image with Gemini:', error);
    // Fallback to demo images if API call fails
    const categoryImages = selectCategory(prompt);
    return {
      imageUrl: categoryImages[Math.floor(Math.random() * categoryImages.length)]
    };
  }
};

export const generateImageWithGroq = async (prompt: string): Promise<ImageGenerationResponse> => {
  // For now, Groq doesn't have image generation capability
  // So we'll use the demo images
  await new Promise(resolve => setTimeout(resolve, 1500));
  
  const categoryImages = selectCategory(prompt);
  return {
    imageUrl: categoryImages[Math.floor(Math.random() * categoryImages.length)]
  };
};
